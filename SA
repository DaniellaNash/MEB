

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define MAX_NUM_NODE 100
#define FALSE 0
#define TRUE 1

//each bit of the solution is an edge
// number of edges = number of nodes squared
//
//loops --> exist if they have the same ancestor (Dept first Search)
        //If an unexplored edge leads to a node visited before, then the graph contains a cycle.
        //NO LONGEr EXISTS

//make initialisation random
//change weight to distance to power **do it in cost function
//store data


//make sure when you remove an edge
        //remove before you add => no loops
        //remove random node, this splits the tree into two branches
        //add edge from each branch randomly
        //find nodes at each branch using DFS
        //CHECK THIS


typedef struct Edge
{
    int weight;//distance
    int label;
    int calculated;
}edge;

int rand_binary(void);
int rand_btw(int Min, int Max,int not_including);
double rand_percentage(void);
void *dfs(int v, int num_nodes,edge new_solution[][10], int visited[]);
int get_num_nodes(void);

void *dfs(int v, int num_nodes, edge new_solution[][10],int visited[]) {
	int i;
    int x,y;
//	printf("\n new_solution Solution is");
//    for(x=1; x<=num_nodes; x++)
//    {
//        printf("\n node %d:",x);
//        for(y=1; y<=num_nodes; y++)
//           printf(" %d",new_solution[x][y].label);
//    }

	visited[v]=1;
	//printf("\n visited:%d",v);
	for (i=1;i<=num_nodes;i++)
        if(new_solution[v][i].label==1)
        {
       //     printf("\n\nhere 1: %d %d",v,i);
            if (!visited[i]==1) //if not yet visited
            {
        //        printf("\n %d->%d",v,i);
                dfs(i, num_nodes, new_solution,visited);
            }
        }
    return 0;
}

int rand_binary(void)
{
    int random;

    random = rand()%2;
    return random;
}

double rand_percentage(void)
{
    double random_value; // random value betw

    random_value = ((float)rand()/(float)(RAND_MAX+1))*100;//version 1
//    Alternatively:
//    random_value = ((rand()%10000000)/10000000);

    return random_value;
}

int rand_btw(int Min, int Max,int not_including)
{
//     Generates random number between min and max, inclusive.
//    From: http://cboard.cprogramming.com/c-programming/145187-how-pick-random-number-between-x-y.html

    int range, result, cutoff,random;
    redo:
    if (Min >= Max)
        return Min; // only one outcome possible, or invalid parameters
    range = Max-Min+1;
    cutoff = (RAND_MAX / range) * range;

//     Rejection method, to be statistically unbiased.
    do
    {
        result = rand();
    }
    while (result >= cutoff);
    random = result % range + Min;
    if(not_including !=0 )
        if(random==not_including)
            goto redo;
    return random;
}

int get_num_nodes(void)
{
    int num_nodes;
    printf("\nEnter the number of nodes:");
    scanf("%d",&num_nodes);
    return num_nodes;
}

int main()
{
    //initialise data
    double T = 1.0;//"Usually, the temperature is started at 1.0 and is decreased at the end of each iteration by multiplying it by a constant called Î±" 7
    //by http://katrinaeg.com/simulated-annealing.html
    //typical choices are between 0.8 and 0.99.
    double T_min = 0.00001; //min temp to be reached
    double alpha = 0.9;//depreciation constant used for temperature after each iteration
    double ap=0.0;
    int delta=0;

    //set default setting
    int num_edges=1;
    int old_cost=0,new_cost=0;
    int num_nodes =0, weight =0;
    int visited [400]={0};//set all nodes
    int branchN [400] = {0},branchM [400] = {0};

    //set other variables
    int rand;
    int n,m,n_new,m_new;
    int x,y,i=1,j;
    int a[10]={0},b[10]={0};
    int iteration =1;
    int counter =0;
    int nodeN_connection[10]={0}, nodeM_connections[10]={0};
    int edgeRemoved = FALSE, edgeAdded = FALSE;

    FILE *fp;

    //creating new file with write mode
    fp=fopen("testSA.txt","w");
    if(fp==NULL)
    {
        printf("Error!");
        exit(1);
    }
    fprintf(fp,"%s %s\t%s %s\t%s\n" ,"Iteration","number","Total",
            "Energy","Solution");

    num_nodes = get_num_nodes();
    edge initial_SA[10][10];
    edge current_SA[10][10];
    edge new_solution[10][10];
    edge temp[10][10];
    edge energy[10][10];

    //ask for the energy needed of each edge the node takes and store them
    printf("\nEnter the network topology matrix:\n");
    for(x=1; x<=num_nodes; x++)
        for(y=1; y<=num_nodes; y++)
            scanf("%d",&initial_SA[x][y].weight);

    for(x=1; x<=num_nodes; x++)
        for(y=1; y<=num_nodes; y++)
        {
            temp[x][y].weight = initial_SA[x][y].weight;//store data of weights as initial_SA.weight will be modified temporarily for calculations
            initial_SA[x][y].label =0;//initially start with no tree
            initial_SA[x][y].calculated=0;
            visited[x]=0;
        }

    visited[1]=1;//set node one as the source node

    //generate initial random solution (TREE MST - no loops)
   while(num_edges < num_nodes)//have required #edges = #node-1
	{
        for(x=1; x<=num_nodes; x++)
            for(y=1; y<=num_nodes; y++)//for all edges
                if(visited[x]!=0)//if node is visited
                    if(initial_SA[x][y].weight!=0) //if edge is possible
                        if(visited[y]==0)//if node is not yet visited
						{
							rand = rand_binary();
							initial_SA[x][y].label=initial_SA[y][x].label=rand;//randomly add an edge
							if (rand == 1)
							{
								visited [y] = 1;
								printf("\n Edge1 %d:(%d %d) energy:%d, label:%d",num_edges++,x,y,initial_SA[x][y].weight,initial_SA[x][y].label);
								for(n=1; n<=num_nodes; n++)
									if(n!=y)//find different edge connected to node x
										if (initial_SA[x][n].weight != 0)//if edge is possible
											if(initial_SA[x][n].weight<= initial_SA[x][y].weight)// node can reach all other nodes with equal or lower tx power
												if(visited[n]==0)//if node is not yet visited
												{
												    visited[n]=1;
                                                    initial_SA[x][n].label = 1;
                                                    initial_SA[n][x].label = 1;
                                                    printf("\n Edge2 %d:(%d %d) energy:%d, label:%d",num_edges++,x,n,initial_SA[x][n].weight,initial_SA[x][n].label);
                                                    initial_SA[x][n].weight=initial_SA[n][x].weight=0;//make sure same edge is not chosen twice
												}
								initial_SA[x][y].weight=initial_SA[y][x].weight=0;//make sure same edge is not chosen twice
							}
						}
	}

	//transfer original weight back
    for(x=1; x<=num_nodes; x++)
        for(y=1; y<=num_nodes; y++)
            initial_SA[x][y].weight = temp[x][y].weight;

    //set current solution to the initial solution generated
    for(x=1; x<=num_nodes; x++)
        for(y=1; y<=num_nodes; y++)
        {
            current_SA[x][y].weight = initial_SA[x][y].weight;
            current_SA[x][y].label = initial_SA[x][y].label;
            current_SA[x][y].calculated = initial_SA[x][y].calculated;
        }

    printf("\n\n\n\n Initial Solution is");
    for(x=1; x<=num_nodes; x++)
    {
        printf("\n node %d:",x);
        for(y=1; y<=num_nodes; y++)
           printf(" %d",current_SA[x][y].label);
    }

    //cost function
    for(x=1; x<=num_nodes; x++)
    {
        weight =0;
        for(y=1; y<=num_nodes; y++)
            if(current_SA[x][y].label ==1)//check if edge is in the solution
            {
                if(current_SA[x][y].calculated==0)//if not a symmetry edge
                    if(weight<current_SA[x][y].weight)//find highest energy used per node
                        weight = current_SA[x][y].weight;

                current_SA[x][y].calculated=1;
                current_SA[y][x].calculated=1;
            }
        old_cost += weight;//find total weight
    }
    printf("\n First iteration cost = %d\n",old_cost);

    //main algorithm
    T=0;
    while (T <=3)//max generation //CHANGE THIS BACK TO T<=T_min
        {
            printf("\n\n    Iteration: %d",iteration++);
            fprintf(fp,"\n\t\t%i\t\t\t%d\t\t",iteration,old_cost );
            for(i=1; i<num_nodes; i++)
            {
                fprintf(fp,"%d",current_SA[y][x].label);
            }

            i = 1;//reset counter for neighbor-cost-compare-move process
            //CHANGE BACK TO i<=100
            while (i <= 2)//"neighbor-cost-compare-move process
                //process is carried about many times (typically somewhere between 100 and 1,000) at each temperature"
                //by http:katrinaeg.com/simulated-annealing.html
            {
                printf("\n\n Neighbor-cost-compare-move iteration: %d",i);

                //neighbour function
                //temperature decreases by a factor of alpha after each generation until the minimum temp is reached
                for(x=1; x<=num_nodes; x++)
                    for(y=1; y<=num_nodes; y++)
                        new_solution[x][y] = current_SA[x][y];

                while (edgeRemoved == FALSE)//remove a random edge
                {
                    n = rand_btw(1,num_nodes,0);//select two random nodes to remove the edge from
                    m = rand_btw(1,num_nodes,n);
                    while(new_solution[n][m].label ==0)//make sure that the edge is in the current solution.
                        //while edge is not in solution, find another edge until solution edge is found
                        //Note, if edge is in current solution then edge is also possible i.e. has a weight>0
                    {
                        n = rand_btw(1,num_nodes,0);
                        m = rand_btw(1,num_nodes,n);//prevent picking the same node
                    }
                    printf("\n Remove Edge (%d %d)",n,m);
                    new_solution[n][m].label =new_solution[m][n].label= 0;//remove this random edge from the solution
                    edgeRemoved = TRUE;//this separates the tree into two branches
                }
                while (edgeAdded==FALSE)//add edge between the two branches to make a complete tree
                {
                    //DFS function
                    //find nodes in n branch using DFS
                    for(x=1; x<=num_nodes; x++)//create storage space to list nodes in each branch
                    {
                        branchN[x]=0;
                        branchM[x]=0;
                    }
                    dfs(n,num_nodes,new_solution,branchN);
                    printf("\n node N is connected to node:");

                    for (i=1;i<=num_nodes;i++) {
                        if(branchN[i]==1)
                          printf(" %d",i);
                    }
                    //find nodes in n branch using DFS
                    dfs(m,num_nodes,new_solution,branchM);
                    printf("\n node M is connected to node: ");

                    for (i=1;i<=num_nodes;i++) {
                        if(branchM[i]==1)
                          printf("% d",i);
                    }

                    //select random node from each branch branchM and branchN
                    n_new = rand_btw(1,num_nodes,0);//select two random nodes
                    m_new = rand_btw(1,num_nodes,n_new);
                    printf("\n random n_new:%d and m_new:%d",n_new,m_new);

                     while(branchN[n_new]==0)//make sure random node is in the correct branch
                        n_new = rand_btw(1,num_nodes,0);
                     while(branchM[m_new]==0)
                        m_new = rand_btw(1,num_nodes,0);
                    printf("\n correct branch n_new:%d and m_new:%d",n_new,m_new);

                     //make sure edge is possible between the two nodes
                     while(new_solution[n_new][m_new].weight ==0)//while edge is not possible, find another edge until a possible edge is found
                        {
                            n_new = rand_btw(1,num_nodes,0);//select two random nodes
                            m_new = rand_btw(1,num_nodes,n_new);

                            while(branchN[n_new]==0)//make sure random node is in the correct branch
                                n_new = rand_btw(1,num_nodes,0);
                            while(branchM[m_new]==0)
                                m_new = rand_btw(1,num_nodes,0);
                        }
                    printf("\n correct branch and exist n:%d and m:%d",n_new,m_new);
                    printf("\n Add Edge (%d %d)",n_new,m_new);
                    new_solution[n_new][m_new].label =new_solution[m_new][n_new].label= 1;//remove this random edge from the solution
                    edgeAdded = TRUE;
                }

                num_edges = 1;//set number of edges back to default
                for(x=1; x<=num_nodes; x++)//print out new_solution
                    for(y=1; y<=num_nodes; y++)
                    {
                        if(new_solution[x][y].label == 1)
                            printf("\n Edge %d:(%d %d) energy:%d",num_edges++,x,y,new_solution[x][y].weight);
                    }

                //cost function
                for(x=1; x<=num_nodes; x++)
                {
                    weight =0;
                    for(y=1; y<=num_nodes; y++)
                        if(new_solution[x][y].label ==1)//check if edge is in the solution
                        {
                            if(new_solution[x][y].calculated==0)//if not a symmetry edge
                                if(weight<new_solution[x][y].weight)//find highest energy used per node
                                    weight = new_solution[x][y].weight;

                            new_solution[x][y].calculated=1;
                            new_solution[y][x].calculated=1;
                        }
                    new_cost += weight;//find total weight
                }printf("\n Total cost is %d\n\n", new_cost);
//
//                //acceptance probability function
//                delta = (old_cost-new_cost);
//                ap = (exp(-delta/T)); //this is the typical equation used
//
//                if(new_cost < old_cost)//if new_solution has less energy select it
//                {
//                    for(x=1; x<=num_nodes; x++)
//                        for(y=1; y<=num_nodes; y++)
//                            current_SA[x][y] = new_solution[x][y];
//                    old_cost = new_cost;
//                }
//                else //if new_solution uses more energy maybe select it
//                {
//                    if (ap > rand_btw(0,1,0))
//                    {
//                        for(x=1; x<=num_nodes; x++)
//                            for(y=1; y<=num_nodes; y++)
//                                current_SA[x][y] = new_solution[x][y];
//                        old_cost = new_cost;
//                    }
//                }

                i += 1;
                edgeAdded = FALSE;//reset value
                edgeRemoved = FALSE;//reset value
            }
            //temperature decreases by a factor of alpha after each generation until the minimum temp is reached
            //T = T*alpha;
            //CHANGE T + T*ALPHA BACK
            T++;//
        }

   printf("\n\n\n\n ****Final Solution is****");
    for(x=1; x<=num_nodes; x++)
    {
        printf("\n node %d:",x);
        for(y=1; y<=num_nodes; y++)
           printf(" %d",current_SA[x][y].label);
    }

    printf("\n Total cost is %d\n\n", old_cost);
    return 0;
}
