

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define MAX_NUM_NODE 100
#define FALSE 0
#define TRUE 1

//each bit of the solution is an edge
// number of edges = number of nodes squared
typedef struct Edge
{
    int weight;//distance
    int label;
}edge;

int rand_binary(void);
int rand_btw(int Min, int Max);
double rand_percentage(void);

int get_num_nodes(void);

int rand_binary(void)
{
    int random;

    random = rand()%2;
    return random;
}

double rand_percentage(void)
{
    double random_value; // random value betw

    random_value = ((float)rand()/(float)(RAND_MAX+1))*100;//version 1
//    Alternatively:
//    random_value = ((rand()%10000000)/10000000);

    return random_value;
}

int rand_btw(int Min, int Max)
{
//     Generates random number between min and max, inclusive.
//    From: http://cboard.cprogramming.com/c-programming/145187-how-pick-random-number-between-x-y.html

    int range, result, cutoff;

    if (Min >= Max)
        return Min; // only one outcome possible, or invalid parameters
    range = Max-Min+1;
    cutoff = (RAND_MAX / range) * range;

//     Rejection method, to be statistically unbiased.
    do
    {
        result = rand();
    }
    while (result >= cutoff);

    return result % range + Min;
}

int get_num_nodes(void)
{
    int num_nodes;
    printf("\nEnter the number of nodes:");
    scanf("%d",&num_nodes);
    return num_nodes;
}

int main()
{
//    initialise data
    double T = 1.0;
    double T_min = 0.00001;
    double alpha = 0.9;
    double ap=0.0;
    int n,m,x,y,i=1,j;
    int delta=0;

    int num_nodes =0;
    int rand;
    int old_cost=0,new_cost=0;
    int edgeRemoved = FALSE, edgeAdded = FALSE;
    int visited [400]={0};//set all nodes
    int num_edges=1;

    num_nodes = get_num_nodes();
    edge initial_SA[10][10];
    edge current_SA[10][10];
    edge new_solution[10][10];
    edge temp[10][10];


//    ask for the energy needed of each edge the node takes and store them
    printf("\nEnter the network topology matrix:\n");
    for(x=1; x<=num_nodes; x++)
        for(y=1; y<=num_nodes; y++)
        {
            scanf("%d",&initial_SA[x][y].weight);
        }
    visited[1]=1;
    while(num_edges < num_nodes)//have required #edges = #node-1
    {
        for(x=1; x<=num_nodes; x++)
            for(y=1; y<=num_nodes; y++)//for all edges
            {
                if(visited[x]!=0)//if node is visited
                {
                    if(initial_SA[x][y].weight!=0) //if edge is possible
                    {
                        rand = rand_binary();
                        initial_SA[x][y].label=rand;//randomly add an edge
                        if (initial_SA[x][y].label == 1)
                        {
                            visited [y] = 1;
                            printf("\n Edge %d:(%d %d) energy:%d",num_edges++,x,y,initial_SA[x][y].weight);
                            for(n=1; n<=num_nodes; n++)
                                if(n!=y)
                                    if(initial_SA[x][n].weight<= initial_SA[y][x].weight)// node can reach all other nodes with equal or lower tx power
                                    {
                                        visited[n]=1;
                                        initial_SA[x][n].label == 1;
                                        printf("\n Edge %d:(%d %d) energy:%d",num_edges++,x,n,initial_SA[y][x].weight);
                                        temp[x][n].weight=initial_SA[x][n].weight; //store value of weight
                                        initial_SA[x][y].weight=initial_SA[y][x].weight=0;//make sure same edge is not chosen twice
                                    }
                            temp[x][y].weight=initial_SA[x][y].weight; //store value of weight
                            initial_SA[x][y].weight=initial_SA[y][x].weight=0;//make sure same edge is not chosen twice
                        }
                    }
                    else
                        initial_SA[x][y].label=0;//if edge is not possible don't pick
                }
            }
    }
    for(x=1; x<=num_nodes; x++)
        for(y=1; y<=num_nodes; y++)
            current_SA[x][y] = temp[x][y];
//    cost function
    for(x=1; x<=num_nodes; x++)
        for(y=1; y<=num_nodes; y++)
            if(current_SA[x][y].label ==1)
                old_cost += current_SA[x][y].weight;
    printf("cost = %d",old_cost);
//
//    while (T > T_min)
//        {
//            while (i <= 100)
//            {
//                //neighbour function
//                while (edgeRemoved == FALSE)
//                {
//                    n = rand_btw(1,num_nodes);
//                    m = rand_btw(1,num_nodes);
//
//                    while(current_SA[n][m].weight==0)
//                    {
//                        n = rand_btw(1,num_nodes);
//                        m = rand_btw(1,num_nodes);
//                    }
//                    if(current_SA[n][m].label == 1)
//                    {
//                        current_SA[n][m].label = 0;
//                        edgeRemoved = TRUE;
//                    }
//                }
//                while (edgeAdded == FALSE)
//                {
//                    n = rand_btw(1,num_nodes);
//                    m = rand_btw(1,num_nodes);
//
//                    while(current_SA[n][m].weight==0)
//                    {
//                        n = rand_btw(1,num_nodes);
//                        m = rand_btw(1,num_nodes);
//                    }
//                    if(current_SA[n][m].label == 0)
//                    {
//                        current_SA[n][m].label = 1;
//                        edgeAdded = TRUE;
//                    }
//                }
//                for(x=1; x<=num_nodes; x++)
//                    for(y=1; y<=num_nodes; y++)
//                        new_solution[x][y] = current_SA[x][y];
//                //cost function
//                for(x=1; x<=num_nodes; x++)
//                    for(y=1; y<=num_nodes; y++)
//                        if(new_solution[x][y].label ==1)
//                            new_cost += new_solution[x][y].weight;
//                //acceptance probability function
//                delta = (old_cost-new_cost);
//                ap = (exp(-delta/T));
//
//                if (ap > rand_percentage())
//                {
//                     for(x=1; x<=num_nodes; x++)
//                        for(y=1; y<=num_nodes; y++)
//                            current_SA[x][y] = new_solution[x][y];
//                    old_cost = new_cost;
//                }
//
//                i += 1;
//                edgeAdded = FALSE;
//                edgeRemoved = FALSE;
//            }
//            T = T*alpha;
//        }
//
//    printf("\nSolution is");
//    for(x=1; x<=num_nodes; x++)
//        for(y=1; y<=num_nodes; y++)
//           printf("%d",current_SA[x][y].label);
//
//    printf("\n Old cost is %d", old_cost);
    return 0;
}
