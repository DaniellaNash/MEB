#include<stdio.h>         //to use the printf function
#include<conio.h>         //to use the getche function
#include<stdlib.h>        //to use the rand function
#include<math.h>          //to use the pow function
#include<time.h>          //to use the time function

//define variables

//Limits on user input parameter values
#define MAX_CHROMO_SIZE             999 //the number of nodes
#define MIN_CHROMO_SIZE             2
#define MAX_POP_SIZE                500
#define MIN_POP_SIZE                4
#define MAX_ENERGY                  0

#define MAX_MUTATION_RATE           1
#define MIN_MUTATION_RATE           0
#define MAX_TX_DISTANCE             999
//Standard values
#define MAX_GENERATIONS             300

//creating the Edge structure
typedef struct Edge//per solution
{
    int label;//label
    float weight;//energy of each edge
} edge;

// creating the chrom structure
typedef struct Chrom
{
    edge **gene;
    float fitness_score;

} chrom;   // a chrom type

void intro_objective_function (void);
int generate_rand(int Min, int Max);
float generate_rand_float(void);
int get_restart(void);
int rand_binary(void);

//get the parameter variables
int get_num_generation(void);
int get_population_size(void);
int get_chromosome_size(void);//the number of edges = number of nodes - 1
float get_mutation_rate(void);

//get the strategy
int get_selection_strategy(void);
int get_crossover_strategy(void);
int get_mutation_strategy(void);

void *item_data(int num_nodes);
float total_value(chrom ***next_population, int num_nodes);
float cost(chrom ***next_population, int num_nodes,int i);
float Objective_function(chrom ***next_population, int num_nodes,int i);
void *binary_population(chrom ***current_population,int pop_size, int num_nodes);

//select strategy for each operator
void *do_selection_operator(int selection,chrom ***next_population,int num_nodes, int pop_size);
void *do_crossover_operator(int crossover,chrom ***next_population,int num_nodes, int pop_size);
void *do_mutation_operator(int mutation,chrom ***next_population,int num_nodes, int pop_size,float mutation_rate);

//selection strategies
void *selection_roulettewheel(int pop_size,chrom ***next_population, int num_nodes);
void *selection_tournament(int pop_size,chrom ***next_population, int num_nodes);
void *selection_elitism_sort(int pop_size,chrom ***next_population,int num_nodes,int show);
void *selection_rank(int pop_size,chrom ***next_population, int num_nodes);

//crossover strategies
//void *crossover_sameBranches(chrom next_population[],int pop_size,int num_nodes,edge edge_energy[]);
//void *crossover_swapBranches(chrom next_population[],int pop_size,int num_nodes,edge edge_energy[]);

//mutation strategies
//void *mutation_addRemove(int num_nodes, int pop_size, chrom next_population[],float mutation_rate,edge edge_energy[]);
//void *mutation_loopRemove(int num_nodes, int pop_size, chrom next_population[],float mutation_rate,edge edge_energy[]);


int main()
{
    int i,j;
    int x,y;
    int n;
    float distance;
    int rand;
    int restart=0,show=0;
    int pop_size, num_nodes;
    float mutation_rate;
    int current_generation, num_gen;
    int selection, crossover, mutation;

    float sum_energy;
    float new_cost=0.0;
    float weight;
    int num_edges =1;
    int* visited;
    float* cost;

    FILE *fp;

    //creating new file with write mode
    fp=fopen("testGA.txt","w");
    if(fp==NULL)
    {
        printf("Error!");
        exit(1);
    }
    fprintf(fp,"%s %s\t%s %s\t\t%s %s\t%s\n" ,"Generation","number","Fitness",
            "Score","Total","energy","BINARY");

    srand(time(NULL));// refresh random values at every execution

    do
    {
        intro_objective_function (); //introduction plus the objective function declaration
        num_gen = get_num_generation();        // get the stopping criterion
        pop_size = get_population_size();
        num_nodes = get_chromosome_size();  //get number of edges = number of nodes - 1

//*****************************************************UNCOMMENT THESE LATER***********************************
//        mutation_rate = get_mutation_rate();
//        selection = get_selection_strategy(); // get strategies for the operators
//        crossover = get_crossover_strategy();
//        mutation = get_mutation_strategy();
//*************************************************************************************************************

        chrom* current_population;//initialize the population arrays
        chrom* next_population;
        chrom* temp;

        current_population = malloc(num_nodes * sizeof(current_population));
        temp = malloc(num_nodes * sizeof(temp));
        next_population = malloc(num_nodes * sizeof(next_population));
        visited = (int *)malloc(num_nodes * sizeof(int));

        if(current_population == NULL||next_population == NULL|| temp == NULL||visited==NULL)
            fprintf(fp,"ERROR: Memory allocation failed!");
        for(x = 1; x <= num_nodes; x++)
        {
            current_population[x].gene = malloc(num_nodes * sizeof(edge*));
            next_population[x].gene = malloc(num_nodes * sizeof(edge*));
            if(current_population[x].gene == NULL||next_population[x].gene == NULL)
                    fprintf(fp,"ERROR: Memory allocation failed!");

            for(y = 1; y <= num_nodes; y++)
            {
                current_population[x].gene[y] = malloc(num_nodes * sizeof(edge));
                next_population[x].gene[y] = malloc(num_nodes * sizeof(edge));
                if(current_population[x].gene[y] == NULL||next_population[x].gene[y] == NULL)
                    fprintf(fp,"ERROR: Memory allocation failed!");
            }
        }

        //ask for the energy needed of each edge the node takes and store them
        printf("\nEnter the network topology matrix:\n");
        for(i=1;i<=pop_size;i++)
            for(x=1; x<=num_nodes; x++)
                for(y=1; y<=num_nodes; y++)
                {
                    scanf("%f", &distance);
                    current_population[i].gene[x][y].weight = distance;
                }
        for(i=1;i<=pop_size;i++)
            for(x=1; x<=num_nodes; x++)
                for(y=1; y<=num_nodes; y++)
                {
                    temp[i].gene[x][y].weight = current_population[i].gene[x][y].weight;//store data of weights as initial_SA.weight will be modified temporarily for calculations
                    current_population[i].gene[x][y].label =0;//initially start with no tree
                    visited[x]=0;//no nodes visited at the start
                }
        visited[1]=1;//set node one as the source node

    printf("\n\n\t Initial population");
    //make random solutions for initial populations
    for(i=1;i<=pop_size;i++)//for each chromosome

    {
        for(j=2;j<=num_nodes;j++)//for each solution clear the visited list (j=2 as visited list must have 1 in the first slot to indicate source node)
            visited[j]=0;
        while(num_edges < num_nodes)//have required #edges = #node-1
        {
            for(x=1; x<=num_nodes; x++)
                for(y=1; y<=num_nodes; y++)//for all edges
                    if(visited[x]!=0)//if node is visited
                        if(current_population[i].gene[x][y].weight!=MAX_ENERGY) //if edge is possible
                            if(visited[y]==0)//if node is not yet visited
                            {
                                rand = rand_binary();
                                current_population[i].gene[x][y].label=rand;//randomly add an edge
                                if (rand == 1)
                                {
                                    visited [y] = 1;
                                    printf("\n Edge1 %d:(%d %d) energy:%.1f, label:%d",num_edges++,x,y,current_population[i].gene[x][y].weight,current_population[i].gene[x][y].label);
                                    for(n=1; n<=num_nodes; n++)
                                        if(n!=y)//find different edge connected to node x
                                            if (current_population[i].gene[x][n].weight != MAX_ENERGY)//if edge is possible
                                                if(current_population[i].gene[x][n].weight<= current_population[i].gene[x][y].weight)// node can reach all other nodes with equal or lower tx power
                                                    if(visited[n]==0)//if node is not yet visited
                                                    {
                                                        visited[n]=1;
                                                        current_population[i].gene[x][n].label = 1;
                                                        printf("\n Edge2 %d:(%d %d) energy:%.1f, label:%d",num_edges++,x,n,current_population[i].gene[x][n].weight,current_population[i].gene[x][n].label);
                                                        current_population[i].gene[x][n].weight=current_population[i].gene[n][x].weight=MAX_ENERGY;//make sure same edge is not chosen twice
                                                    }
                                    current_population[i].gene[x][y].weight=current_population[i].gene[y][x].weight=MAX_ENERGY;//make sure same edge is not chosen twice
                                }
                            }
        }

    }

        //transfer original weight back
        for(i=1;i<=pop_size;i++)
            for(x=1; x<=num_nodes; x++)
                for(y=1; y<=num_nodes; y++)
                    current_population[i].gene[x][y].weight = temp[i].gene[x][y].weight;

//*************************************************************************************************************
//        binary_population(current_population,pop_size,num_nodes); //binary representation
//        item_data(num_nodes,edge_energy);
//*************************************************************************************************************
        for(current_generation=1; current_generation<num_gen+1 ; current_generation++) // iterate for the number of generations wanted
        {
            printf("\n\n\n\tGeneration number: %d\n\n",current_generation); // print the iteration number

            for(j=1; j<=pop_size; j++)
            {
                next_population[j]=current_population[j];//copy current population to next population in order to adjust it

                printf("\n Chromosome[%d] = ",j);
                for(x=1; x<=num_nodes; x++)
                {
                    printf("\n Node %d:",x );
                    for(y=1; y<=num_nodes; y++)
                        printf(" %d",next_population[j].gene[x][y].label);
                }

//*************************************************************************************************************
//                cost function inside --> next_population[j].fitness_score = Objective_function(next_population,num_nodes,j); //fitness score of chromosome
//*************************************************************************************************************
               new_cost = 0.0;
                for(x=1; x<=num_nodes; x++)//for all edges
                {
                    weight =0.0;//find the largest tx on each node
                    for(y=1; y<=num_nodes; y++)
                        if(next_population[j].gene[x][y].label == 1)
                                if(weight<next_population[j].gene[x][y].weight)//find highest energy used per node
                                    weight = next_population[j].gene[x][y].weight;

                    new_cost += weight;//find total weight
                }
                printf("\n Total cost is %.2f", new_cost);

//*************************************************************************************************************
//                next_population[j].fitness_score = Objective_function(next_population,num_nodes,j); //fitness score of chromosome
                next_population[j].fitness_score = new_cost; //temporary
//*************************************************************************************************************

                printf("\n fitness=%.2f",next_population[j].fitness_score); // print the fitness and value of chromosome for each respective chromosome
            }
//*****************************************************UNCOMMENT THESE LATER***********************************
//            selection_elitism_sort(pop_size, next_population,  num_nodes, show, edge_energy);
//            sum_energy = cost(next_population[1],num_nodes,edge_energy);
//            fprintf(fp,"\n\t\t%i\t\t\t%f\t\t%f\t\t",current_generation,cost[1],sum_energy );

//*************************************************************************************************************

            printf("\n\n\t\tbest chromosome of gen %d: ", current_generation);
            for(x=1; x<=num_nodes; x++)
            {
                printf("\n\t Node %d:",x );
                for(y=1; y<=num_nodes; y++)
                {
                    fprintf(fp,"%d",next_population[1].gene[x][y].label);
                    printf(" %d",next_population[1].gene[x][y].label);
                   // printf(" %.2f",next_population[j].gene[x][y].weight);
                }
            }


//*****************************************************UNCOMMENT THESE LATER***********************************
//            //selection function
//            do_selection_operator(selection,next_population,num_nodes,pop_size, edge_energy);
//            //crossover function
//            do_crossover_operator(crossover,next_population,num_nodes, pop_size, edge_energy);
//            //mutation function
//            do_mutation_operator(mutation,next_population,num_nodes,pop_size, mutation_rate, edge_energy);
//*************************************************************************************************************
            for(i=1; i<=pop_size; i++)
            {
                current_population[i]=next_population[i]; //copy the chromes of next population to current population
            }
        }
        restart = get_restart();
    }
    while(restart==1);
    //closing the file from write mode
    fclose(fp);

    fflush(NULL);

    return 0;
}

//void *selection_elitism_sort(int pop_size,chrom ***next_population, int num_nodes,int show, int cost[])//commented
//{
//    //descending order
//    // population is sorted according to their fitness such that there is no way that strong and weak chromosomes reproduce.
//    int i,j;
//    chrom temporary;
//
//    if (show==1)
//        //printf("\n\n\tElitism (sorting) selection:");
//
//        for(i=1; i<=pop_size; i++)
//        {
//            for(j=1; j<pop_size; j++) //dont include last chromosome as it has nothing to compare with
//            {
//                if(cost[j+1] > cost[j]) // if the next chromosome is better than the previous (maximizing)
//                {
//                    temporary = next_population[j+1]; // store the chromosome
//                    next_population[j+1] = next_population[j]; // then switch them around such that chromosomes are ordered from best to worst
//                    next_population[j] = temporary;
//                }
//            }
//        }
//    //printf("\n\n\tDescending order of fitness:");
//    for(i=1; i<=pop_size; i++)
//    {
//        //printf("\n\tchromosome[%d] = ",i);//print out new chromosome order
//        for(j=0; j<=num_nodes; j++)
//        {
//            //printf("%d",next_population[i].gene[j]);
//        }
//
//        cost[i] = Objective_function(next_population[i],num_nodes,edge_energy); //fitness score of chromosome
//        //printf(" fitness=%f",next_population[i].fitness_score); // print the fitness and value of chromosome for each respective chromosome
//    }
//    fflush(NULL);
//    return(0);
//}
//
//void *selection_tournament(int pop_size,chrom ***next_population, int num_nodes)//commented
//{
//    int i,j;
//    int rand1_individual,rand2_individual;
//    int rand_r, tournament_size= 8;
//    chrom temporary[pop_size];
//
//    //printf("\n\n\tTournament selection:");
//
//    for(i=1; i<pop_size+1; i++)
//    {
//        rand1_individual = generate_rand(1,pop_size);//get random individuals
//        rand2_individual = generate_rand(1,pop_size);//get random individuals
//
//        rand_r = generate_rand(0,10);//get random number r
//        if(rand_r<tournament_size) // if r is less than the predetermined tournament size thatn select the fittest individula
//        {
//            if(cost[rand1_individual] > cost[rand2_individual]) // store the fittest individual
//                temporary[i]=next_population[rand1_individual];
//            else
//                temporary[i]=next_population[rand2_individual];
//        }
//        else
//        {
//            if(next_population[rand1_individual].fitness_score < next_population[rand2_individual].fitness_score) // store the fittest individual
//                temporary[i]=next_population[rand1_individual];
//            else
//                temporary[i]=next_population[rand2_individual];
//        }
//    }
//    for(i=1; i<pop_size+1; i++)
//    {
//        next_population[i] = temporary[i];
//        //printf("\n\tchromosome[%d] = ",i);//print out new chromosome order
//        for(j=0; j<num_nodes; j++)
//        {
//            //printf("%d",next_population[i].gene[j]);
//        }
//
//        next_population[i].fitness_score = Objective_function(next_population[i],num_nodes,edge_energy); //fitness score of chromosome
//        //printf(" fitness=%f",next_population[i].fitness_score); // print the fitness and value of chromosome for each respective chromosome
//    }
//    fflush(NULL);
//    return(0);
//}
//
//void *selection_rank(int pop_size,chrom ***next_population, int num_nodes)//commented
//{
//    int i,j,k;
//    int show=0;
//    float likelihood;
//    float total=0, rand_number;
//    chrom temporary[pop_size];
//
//    //printf("\n\n\tRank selection:");
//    selection_elitism_sort(pop_size,next_population,num_nodes,show,edge_energy);
//
//    for (i=1; i<pop_size+1; i++)
//        temporary[i] = next_population[i];
//
//    for(i=1; i<pop_size+1; i++) // create new population
//    {
//        k=0;
//        rand_number = generate_rand(0,100);// get random number
//        likelihood = 100.0/(pop_size); // generate probability of each chromosomes occuring
//        do
//        {
//            k++;
//            total = total + likelihood*k;
//        }
//        while (total < rand_number);
//        temporary[i]=next_population[k];
//    }
//    //printf("\n\n\tNew population:");
//    for(i=1; i<pop_size+1; i++) //print out new chromosome
//    {
//        next_population[i] = temporary[i];
//        //printf("\n\tchromosome[%d] = ",i);
//        for(j=0; j<num_nodes; j++)
//        {
//            //printf("%d",next_population[i].gene[j]);
//        }
//        next_population[i].fitness_score = Objective_function(next_population[i],num_nodes,edge_energy); //fitness score of chromosome
//        //printf(" fitness=%f",next_population[i].fitness_score); // print the fitness and value of chromosome for each respective chromosome
//    }
//    fflush(NULL);
//    return(0);
//}
//
//void *selection_roulettewheel(int pop_size,chrom ***next_population, int num_nodes)
//{
//    int i,j;
//    float r_random;
//    float likelihood[pop_size],sum_likelihood[pop_size+1];
//    float total_fitness=0.0;
//    chrom temporary[pop_size];
//
//    sum_likelihood[0]=0.0;
//    //printf("\n\n\tRoulette wheel selection:");
//
//    for(i=1; i<pop_size+1; i++) // calculate total fitness of population
//    {
//        total_fitness +=  next_population[i].fitness_score;//calculate total fitness of the population
//    }
//    for(j=1; j<pop_size+1; j++) // for each chromosome
//    {
//        likelihood[j] = (next_population[j].fitness_score/total_fitness); // calculate the prob of each chromosome
//        sum_likelihood[j] = sum_likelihood[j-1] + likelihood[j];// calculate the total prob of each chromosome
//        //printf("\n\tlikelihood %.2f",likelihood[j]);
//        //printf("\tsum of likelihood %.2f",sum_likelihood[j]);
//    }
//
//    for(j=1; j<pop_size+1; j++)
//        for(i=1; i<pop_size+1; i++)
//        {
//            //printf("\n\trandom %.2f and sumlikeli[%d] %.2f",r_random,i,sum_likelihood[i]);
//            r_random =generate_rand_float();
//            if ((r_random> sum_likelihood[i]) && (likelihood[i]<likelihood[i+1]));
//            temporary[i]=next_population[i];
//        }
//    for(i=1; i<pop_size+1; i++) //print out new chromosome
//    {
//        next_population[i] = temporary[i];
//        //printf("\n\tchromosome[%d] = ",i);
//        for(j=0; j<num_nodes; j++)
//        {
//            //printf("%d",next_population[i].gene[j]);
//        }
//        next_population[i].fitness_score = Objective_function(next_population[i],num_nodes,edge_energy); //fitness score of chromosome
//        //printf(" fitness=%f",next_population[i].fitness_score); // print the fitness and value of chromosome for each respective chromosome
//    }
//    fflush(NULL);
//    return(0);
//}
//


//***********************************************************************************************************************
//***********************************************************************************************************************
//***********************************************************************************************************************
//***********************************************************************************************************************
//***********************************************************************************************************************


//void *binary_population(chrom ***current_population,int pop_size, int num_nodes)
//{
//    // create population
//    int j,i;
//    int random;
//    int visited[10]={0};
//    int num_edges  =0;
//    int x,y,rand,n;
//
//    for(j=1; j<pop_size+1; j++) // for each chromosome
//    {
//        num_edges =1;
//
//        for(x=1;x<=num_nodes;x++)
//            visited[x]=0;
//
//        while(num_edges < num_nodes)//have required #edges = #node-1
//        {
//            for(x=1; x<=num_nodes; x++)
//                for(y=1; y<=num_nodes; y++)//for all edges
//                    if(visited[x]!=0)//if node is visited
//                        if(initial_SA[x][y].weight!=MAX_ENERGY) //if edge is possible
//                            if(visited[y]==0)//if node is not yet visited
//                            {
//                                rand = (rand()%2); // creating random value (0 or 1)
//                                initial_SA[x][y].label=rand;//randomly add an edge
//                                if (rand == 1)
//                                {
//                                    visited [y] = 1;
//                                    printf("\n Edge1 %d:(%d %d) energy:%d, label:%d",num_edges++,x,y,initial_SA[x][y].weight,initial_SA[x][y].label);
//                                    for(n=1; n<=num_nodes; n++)
//                                        if(n!=y)//find different edge connected to node x
//                                            if (initial_SA[x][n].weight != MAX_ENERGY)//if edge is possible
//                                                if(initial_SA[x][n].weight<= initial_SA[x][y].weight)// node can reach all other nodes with equal or lower tx power
//                                                    if(visited[n]==0)//if node is not yet visited
//                                                    {
//                                                        visited[n]=1;
//                                                        initial_SA[x][n].label = 1;
//                                                        printf("\n Edge2 %d:(%d %d) energy:%d, label:%d",num_edges++,x,n,initial_SA[x][n].weight,initial_SA[x][n].label);
//                                                        initial_SA[x][n].weight=initial_SA[n][x].weight=MAX_ENERGY;//make sure same edge is not chosen twice
//                                                    }
//                                    initial_SA[x][y].weight=initial_SA[y][x].weight=MAX_ENERGY;//make sure same edge is not chosen twice
//                                }
//                            }
//        }
//
//    }
//
//
//    return(0);
//}
//
//void *item_data(int num_nodes)
//{
//    int i, distance;
//    //ask for the distance needed of each edge the node takes and store them
//    printf("\nEnter the network topology matrix:\n");
//    for(i=1; i<=num_nodes; i++)
//        {
//            scanf("%d",&distance);
//            edge_energy[i].weight=pow(distance,2);
//            if(edge_energy[i].weight==0)
//                edge_energy[i].weight=MAX_TX_DISTANCE;//set non-existing edges to a large number (infinity) to prevent being selected
//        }
//
////    edge_energy[0].distance = 29;
////    edge_energy[1].distance = 10;
////    edge_energy[2].distance = 11;
////    edge_energy[3].distance = 6;
////    edge_energy[4].distance = 4;
////    edge_energy[5].distance = 15;
////    edge_energy[6].distance = 36;
////    edge_energy[7].distance = 22;
////    edge_energy[8].distance = 8;
////    edge_energy[9].distance = 19;
////    edge_energy[10].distance = 10;
////    edge_energy[11].distance = 12;
////    edge_energy[12].distance = 21;
////    edge_energy[13].distance = 14;
////    edge_energy[14].distance = 7;
////    edge_energy[15].distance = 3;
////    edge_energy[16].distance = 46;
////    edge_energy[17].distance = 27;
////    edge_energy[18].distance = 56;
////    edge_energy[19].distance = 19;
////    edge_energy[20].distance = 20;
////    edge_energy[21].distance = 21;
////    edge_energy[22].distance = 42;
////    edge_energy[23].distance = 43;
////    edge_energy[24].distance = 36;
////    edge_energy[25].distance = 25;
////    edge_energy[26].distance = 22;
////    edge_energy[27].distance = 27;
////    edge_energy[28].distance = 44;
////    edge_energy[29].distance = 39;
////    edge_energy[30].distance = 30;
////    edge_energy[31].distance = 51;
////    edge_energy[32].distance = 32;
////    edge_energy[33].distance = 33;
////    edge_energy[34].distance = 34;
//
//    return(0);
//}
//

//float Objective_function(chrom ***next_population, int num_nodes,int i)
//{
//
//    float new_cost=0.0;
//   // float function_value;
//
//    new_cost = cost(next_population,num_nodes,i);
// //   if ()//it does not include all nodes set to 0
//
// //minimise the function
//
//    return(new_cost);
//}


//float cost(chrom ***next_population, int num_nodes,int i)
//{
//    float new_cost = 0.0;
//    int x,y;
//    float weight;
//
//    for(x=1; x<=num_nodes; x++)//for all edges
//    {
//        weight =0.0;//find the largest tx on each node
//        for(y=1; y<=num_nodes; y++)
//            if(next_population[i].gene[x][y].label == 1)
//                    if(weight<next_population[i].gene[x][y].weight)//find highest energy used per node
//                        weight = next_population[i].gene[x][y].weight;
//
//        new_cost += weight;//find total weight
//    }
//    printf("\n Total cost is %f\n\n", new_cost);
//    return new_cost;
//
//}


void *do_mutation_operator(int mutation,chrom ***next_population,int num_nodes, int pop_size, float mutation_rate)
{
    switch (mutation)
    {
    case 1 :
        //mutation_addRemove()
        break;
    case 2 :
        //mutation_loopRemove()
        break;
    default :
        printf("invalid input\n" );
        break;
    }
    return 0;
}

void *do_crossover_operator(int crossover,chrom ***next_population,int num_nodes, int pop_size)
{
    switch (crossover)
    {
    case 1 :
        //crossover_sameBranches
        break;
    case 2 :
        //crossover_swapBranches
        break;
    default :
        printf("invalid input\n" );
        break;
    }
    return 0;
}

void *do_selection_operator(int selection,chrom ***next_population,int num_nodes, int pop_size)
{
    int show=1;
    switch (selection)
    {
    case 1 :
        //selection_elitism_sort( pop_size,next_population,num_nodes,show,edge_energy);
        break;
    case 2 :
        //selection_tournament(pop_size,next_population,num_nodes,edge_energy);
        break;
    case 3 :
        //selection_rank(pop_size,next_population,num_nodes,edge_energy);
        break;
    case 4 :
        //selection_roulettewheel(pop_size,next_population, num_nodes,edge_energy);
        break;
    default :
        printf("invalid input\n" );
        break;
    }
    return 0;
}

int generate_rand(int Min, int Max)
{
    // Generates random number between min and max, inclusive.
    //From: http://cboard.cprogramming.com/c-programming/145187-how-pick-random-number-between-x-y.html

    int range, result, cutoff;

    if (Min >= Max)
        return Min; // only one outcome possible, or invalid parameters
    range = Max-Min+1;
    cutoff = (RAND_MAX / range) * range;

    // Rejection method, to be statistically unbiased.
    do
    {
        result = rand();
    }
    while (result >= cutoff);

    return result % range + Min;
}

int rand_binary(void)
{
    int random;

    random = rand()%2;
    return random;
}

float generate_rand_float(void)
{
    float random_value; // random value betw

    random_value = ((float)rand()/(float)(RAND_MAX+1));//version 1
    //Alternatively:
    //random_value = ((rand()%10000000)/10000000);

    return random_value;
}

int get_restart(void)
{
    int restart; //number of chromosomes entered

    printf("\n\n\n\n\tWould you like to restart? (1 = yes)\t");// ask if they want to restart
    scanf("%d",&restart);

    return restart;
}

float get_mutation_rate(void)
{
    float mutation_rate; //number of chromosomes entered

enter:
    printf("Please enter (float) mutation rate (Minimum %d to Maximum %d):\t",MIN_MUTATION_RATE,MAX_MUTATION_RATE);// Ask for number of chromosomes
    scanf("%f",&mutation_rate); //get the number of chromosomes

    if(mutation_rate <MIN_MUTATION_RATE || mutation_rate>MAX_MUTATION_RATE)
        goto enter;

    return mutation_rate;
}

int get_chromosome_size(void)
{
    int num_nodes; //problem size

    enter:
    printf("Please enter no. of Nodes considered (Min %d to Max %d):\t",MIN_CHROMO_SIZE,MAX_CHROMO_SIZE);// Ask for number of chromosomes
    scanf("%d",&num_nodes); //get the number of chromosomes


    if(num_nodes <MIN_CHROMO_SIZE || num_nodes>MAX_CHROMO_SIZE)
        goto enter;
    return (num_nodes);
}

int get_population_size(void)
{
    int pop_size; //number of population entered
//
//enter:
//    printf("Please enter an even population size (Minimum %d to Maximum of %d):\t",MIN_POP_SIZE,MAX_POP_SIZE);// Ask for number of population
//    scanf("%d",&pop_size); //get the number of population
//
//    if(pop_size <MIN_POP_SIZE || pop_size>MAX_POP_SIZE)
//        goto enter;
//    else if(pop_size%2 !=0)
//        goto enter;

    return pop_size=2;
}

int get_mutation_strategy(void)
{
    int mutation; //number of population entered

enter:
    printf("\n\tChoose a mutation strategy: \
                 \n\t\tAdd/Remove        \t 1       \
                 \n\t\tLoop/Remove       \t 2\
                 \n\t\tYou picked:");// Ask for mutation strategy

    scanf("%d",&mutation); //get the number of population

    if(mutation <1 || mutation>2)
        goto enter;
    return mutation;
}

int get_crossover_strategy(void)
{
    int crossover; //number of population entered

    enter:
    printf("\n\tChoose a crossover strategy: \
                 \n\t\tSame Branches    \t 1       \
                 \n\t\tSwap Branches    \t 2       \
                 \n\t\tYou picked:");// Ask for crossover strategy

    scanf("%d",&crossover); //get the number of population

    if(crossover <1 || crossover>2)
        goto enter;
    return crossover;
}

int get_selection_strategy(void)
{
    int selection; //number of population entered

    enter:
    printf("\n\tChoose a selection strategy: \
                 \n\t\tElitism         \t 1       \
                 \n\t\tTournament      \t 2       \
                 \n\t\tRank            \t 3       \
                 \n\t\tRoulette Wheel  \t 4       \
                 \n\t\tYou picked:");// Ask for selection strategy

    scanf("%d",&selection); //get the number of population

    if(selection <1 || selection>4)
        goto enter;
    return selection;
}

int get_num_generation(void)
{
    int num; //number of generations entered

enter:
    printf("Please enter the number of generations (Minimum 1 to Maximum of %d):\t",MAX_GENERATIONS);// Ask for number of generation for stopping criterion
    scanf("%d",&num); //get the number of generations

    if(num < 1 || num > MAX_GENERATIONS)
        goto enter;
    return num;
}

void intro_objective_function (void)
{
    printf("\n\n\n\n\n\nWelcome to the Genetic Algorithm coded by Daniella Bacud\n"); // Print introduction
}
