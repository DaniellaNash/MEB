#include<stdio.h>         //to use the printf function
#include<conio.h>         //to use the getche function
#include<stdlib.h>        //to use the rand function
#include<math.h>          //to use the pow function
#include<time.h>          //to use the time function

//define variables

//Limits on user input parameter values
#define MAX_CHROMO_SIZE             999 //the number of nodes
#define MIN_CHROMO_SIZE             2
#define MAX_POP_SIZE                500
#define MIN_POP_SIZE                4
#define MAX_ENERGY                  0

#define MAX_MUTATION_RATE           1
#define MIN_MUTATION_RATE           0
#define MAX_TX_DISTANCE             999
//Standard values
#define MAX_GENERATIONS             300

//creating the Edge structure
typedef struct Edge//per solution
{
    int label;//label
    float weight;//energy of each edge
} edge;

// creating the chrom structure
typedef struct Chrom
{
    edge **gene;
    float fitness_score;

} chrom;   // a chrom type

void introduction (void);
int generate_rand(int Min, int Max);
float generate_rand_float(void);
int get_restart(void);
int rand_binary(void);

//get the parameter variables
int get_num_generation(void);
int get_population_size(void);
int get_chromosome_size(void);//the number of edges = number of nodes - 1
float get_mutation_rate(void);

//get the strategy
int get_selection_strategy(void);
int get_crossover_strategy(void);
int get_mutation_strategy(void);

void get_network_topology(int num_nodes, int pop_size, int visited[], chrom *temp, chrom *current_population);
void gen_init_pop(int num_nodes, int pop_size, int visited[], chrom *temp, chrom *current_population);
float cost(int num_nodes,int i,chrom *next_population);
float Objective_function(int num_nodes,int i,chrom *next_population);
void print_out_chroms(int num_nodes,chrom* next_population, int j, int best, int current_generation);

//select strategy for each operator
void *do_selection_operator(int selection,chrom ***next_population,int num_nodes, int pop_size);
void *do_crossover_operator(int crossover,chrom ***next_population,int num_nodes, int pop_size);
void *do_mutation_operator(int mutation,chrom ***next_population,int num_nodes, int pop_size,float mutation_rate);

//selection strategies
void *selection_roulettewheel(int pop_size,chrom ***next_population, int num_nodes);
void *selection_tournament(int pop_size,chrom ***next_population, int num_nodes);
void *selection_elitism_sort(int pop_size,chrom ***next_population,int num_nodes,int show);
void *selection_rank(int pop_size,chrom ***next_population, int num_nodes);

//crossover strategies
//void *crossover_sameBranches(chrom next_population[],int pop_size,int num_nodes,edge edge_energy[]);
//void *crossover_swapBranches(chrom next_population[],int pop_size,int num_nodes,edge edge_energy[]);

//mutation strategies
//void *mutation_addRemove(int num_nodes, int pop_size, chrom next_population[],float mutation_rate,edge edge_energy[]);
//void *mutation_loopRemove(int num_nodes, int pop_size, chrom next_population[],float mutation_rate,edge edge_energy[]);


int main()
{
    int i,j;
    int x,y;
    int n;
    float distance;
    int rand;
    int restart=0,show=0;
    int pop_size, num_nodes;
    float mutation_rate;
    int current_generation, num_gen;
    int selection, crossover, mutation;

    float sum_energy;
    float new_cost=0.0;
    float weight;
    int num_edges =1;
    int* visited;

    FILE *fp;

    //creating new file with write mode
    fp=fopen("testGA.txt","w");
    if(fp==NULL)
    {
        printf("Error!");
        exit(1);
    }
    fprintf(fp,"%s %s\t%s %s\t\t%s %s\t%s\n" ,"Generation","number","Fitness",
            "Score","Total","energy","BINARY");

    srand(time(NULL));// refresh random values at every execution

    do
    {
        introduction (); //introduction plus the objective function declaration
        num_gen = get_num_generation();        // get the stopping criterion
        pop_size = get_population_size();
        num_nodes = get_chromosome_size();  //get number of edges = number of nodes - 1

//*****************************************************UNCOMMENT THESE LATER***********************************
//        mutation_rate = get_mutation_rate();
//        selection = get_selection_strategy(); // get strategies for the operators
//        crossover = get_crossover_strategy();
//        mutation = get_mutation_strategy();
//*************************************************************************************************************

        chrom* current_population;//initialize the population arrays
        chrom* next_population;
        chrom* temp;

        current_population = malloc(num_nodes * sizeof(current_population));
        temp = malloc(num_nodes * sizeof(temp));
        next_population = malloc(num_nodes * sizeof(next_population));
        visited = (int *)malloc(num_nodes * sizeof(int));

        if(current_population == NULL||next_population == NULL|| temp == NULL||visited==NULL)
            fprintf(fp,"ERROR: Memory allocation failed!");
        for(x = 1; x <= num_nodes; x++)
        {
            current_population[x].gene = malloc(num_nodes * sizeof(edge*));
            next_population[x].gene = malloc(num_nodes * sizeof(edge*));
            if(current_population[x].gene == NULL||next_population[x].gene == NULL)
                fprintf(fp,"ERROR: Memory allocation failed!");

            for(y = 1; y <= num_nodes; y++)
            {
                current_population[x].gene[y] = malloc(num_nodes * sizeof(edge));
                next_population[x].gene[y] = malloc(num_nodes * sizeof(edge));
                if(current_population[x].gene[y] == NULL||next_population[x].gene[y] == NULL)
                    fprintf(fp,"ERROR: Memory allocation failed!");
            }
        }
//*************************************************************************************************************
        get_network_topology( num_nodes, pop_size, visited, temp, current_population);//get the matrix of node connections
        gen_init_pop(num_nodes, pop_size, visited, temp,current_population);//generate random population of solution
//*************************************************************************************************************
        for(current_generation=1; current_generation<num_gen+1 ; current_generation++) // iterate for the number of generations wanted
        {
            printf("\n\n\n\tGeneration number: %d\n\n",current_generation); // print the iteration number

            for(j=1; j<=pop_size; j++)
            {
                next_population[j]=current_population[j];//copy current population to next population in order to adjust it
                print_out_chroms( num_nodes,next_population,j,0,current_generation);

                next_population[j].fitness_score = Objective_function(num_nodes,j,next_population); //calculate fitness score of chromosome
                printf("\n Fitness=%.2f",next_population[j].fitness_score); // print the fitness and value of chromosome for each respective chromosome
            }
//*****************************************************UNCOMMENT THESE LATER***********************************
//            selection_elitism_sort(pop_size, next_population,  num_nodes, show, edge_energy);
//*************************************************************************************************************
            sum_energy = cost(num_nodes,1,next_population);
            fprintf(fp,"\n\t%i\t\t%.1f\t\t\t%.1f\t\t",current_generation,next_population[1].fitness_score,sum_energy);
            print_out(num_nodes,next_population,j,1,current_generation);

//*****************************************************UNCOMMENT THESE LATER***********************************
//            //selection function
//            do_selection_operator(selection,next_population,num_nodes,pop_size, edge_energy);
//            //crossover function
//            do_crossover_operator(crossover,next_population,num_nodes, pop_size, edge_energy);
//            //mutation function
//            do_mutation_operator(mutation,next_population,num_nodes,pop_size, mutation_rate, edge_energy);
//*************************************************************************************************************
            for(i=1; i<=pop_size; i++)
                current_population[i]=next_population[i]; //copy the chromes of next population to current population
        }
        restart = get_restart();
    }
    while(restart==1);
    //closing the file from write mode
    fclose(fp);

    fflush(NULL);

    return 0;
}

//void *selection_elitism_sort(int pop_size,chrom ***next_population, int num_nodes,int show, int cost[])//commented
//{
//    //descending order
//    // population is sorted according to their fitness such that there is no way that strong and weak chromosomes reproduce.
//    int i,j;
//    chrom temporary;
//
//    if (show==1)
//        //printf("\n\n\tElitism (sorting) selection:");
//
//        for(i=1; i<=pop_size; i++)
//        {
//            for(j=1; j<pop_size; j++) //dont include last chromosome as it has nothing to compare with
//            {
//                if(cost[j+1] > cost[j]) // if the next chromosome is better than the previous (maximizing)
//                {
//                    temporary = next_population[j+1]; // store the chromosome
//                    next_population[j+1] = next_population[j]; // then switch them around such that chromosomes are ordered from best to worst
//                    next_population[j] = temporary;
//                }
//            }
//        }
//    //printf("\n\n\tDescending order of fitness:");
//    for(i=1; i<=pop_size; i++)
//    {
//        //printf("\n\tchromosome[%d] = ",i);//print out new chromosome order
//        for(j=0; j<=num_nodes; j++)
//        {
//            //printf("%d",next_population[i].gene[j]);
//        }
//
//        cost[i] = Objective_function(next_population[i],num_nodes,edge_energy); //fitness score of chromosome
//        //printf(" fitness=%f",next_population[i].fitness_score); // print the fitness and value of chromosome for each respective chromosome
//    }
//    fflush(NULL);
//    return(0);
//}
//
//void *selection_tournament(int pop_size,chrom ***next_population, int num_nodes)//commented
//{
//    int i,j;
//    int rand1_individual,rand2_individual;
//    int rand_r, tournament_size= 8;
//    chrom temporary[pop_size];
//
//    //printf("\n\n\tTournament selection:");
//
//    for(i=1; i<pop_size+1; i++)
//    {
//        rand1_individual = generate_rand(1,pop_size);//get random individuals
//        rand2_individual = generate_rand(1,pop_size);//get random individuals
//
//        rand_r = generate_rand(0,10);//get random number r
//        if(rand_r<tournament_size) // if r is less than the predetermined tournament size thatn select the fittest individula
//        {
//            if(cost[rand1_individual] > cost[rand2_individual]) // store the fittest individual
//                temporary[i]=next_population[rand1_individual];
//            else
//                temporary[i]=next_population[rand2_individual];
//        }
//        else
//        {
//            if(next_population[rand1_individual].fitness_score < next_population[rand2_individual].fitness_score) // store the fittest individual
//                temporary[i]=next_population[rand1_individual];
//            else
//                temporary[i]=next_population[rand2_individual];
//        }
//    }
//    for(i=1; i<pop_size+1; i++)
//    {
//        next_population[i] = temporary[i];
//        //printf("\n\tchromosome[%d] = ",i);//print out new chromosome order
//        for(j=0; j<num_nodes; j++)
//        {
//            //printf("%d",next_population[i].gene[j]);
//        }
//
//        next_population[i].fitness_score = Objective_function(next_population[i],num_nodes,edge_energy); //fitness score of chromosome
//        //printf(" fitness=%f",next_population[i].fitness_score); // print the fitness and value of chromosome for each respective chromosome
//    }
//    fflush(NULL);
//    return(0);
//}
//
//void *selection_rank(int pop_size,chrom ***next_population, int num_nodes)//commented
//{
//    int i,j,k;
//    int show=0;
//    float likelihood;
//    float total=0, rand_number;
//    chrom temporary[pop_size];
//
//    //printf("\n\n\tRank selection:");
//    selection_elitism_sort(pop_size,next_population,num_nodes,show,edge_energy);
//
//    for (i=1; i<pop_size+1; i++)
//        temporary[i] = next_population[i];
//
//    for(i=1; i<pop_size+1; i++) // create new population
//    {
//        k=0;
//        rand_number = generate_rand(0,100);// get random number
//        likelihood = 100.0/(pop_size); // generate probability of each chromosomes occuring
//        do
//        {
//            k++;
//            total = total + likelihood*k;
//        }
//        while (total < rand_number);
//        temporary[i]=next_population[k];
//    }
//    //printf("\n\n\tNew population:");
//    for(i=1; i<pop_size+1; i++) //print out new chromosome
//    {
//        next_population[i] = temporary[i];
//        //printf("\n\tchromosome[%d] = ",i);
//        for(j=0; j<num_nodes; j++)
//        {
//            //printf("%d",next_population[i].gene[j]);
//        }
//        next_population[i].fitness_score = Objective_function(next_population[i],num_nodes,edge_energy); //fitness score of chromosome
//        //printf(" fitness=%f",next_population[i].fitness_score); // print the fitness and value of chromosome for each respective chromosome
//    }
//    fflush(NULL);
//    return(0);
//}
//
//void *selection_roulettewheel(int pop_size,chrom ***next_population, int num_nodes)
//{
//    int i,j;
//    float r_random;
//    float likelihood[pop_size],sum_likelihood[pop_size+1];
//    float total_fitness=0.0;
//    chrom temporary[pop_size];
//
//    sum_likelihood[0]=0.0;
//    //printf("\n\n\tRoulette wheel selection:");
//
//    for(i=1; i<pop_size+1; i++) // calculate total fitness of population
//    {
//        total_fitness +=  next_population[i].fitness_score;//calculate total fitness of the population
//    }
//    for(j=1; j<pop_size+1; j++) // for each chromosome
//    {
//        likelihood[j] = (next_population[j].fitness_score/total_fitness); // calculate the prob of each chromosome
//        sum_likelihood[j] = sum_likelihood[j-1] + likelihood[j];// calculate the total prob of each chromosome
//        //printf("\n\tlikelihood %.2f",likelihood[j]);
//        //printf("\tsum of likelihood %.2f",sum_likelihood[j]);
//    }
//
//    for(j=1; j<pop_size+1; j++)
//        for(i=1; i<pop_size+1; i++)
//        {
//            //printf("\n\trandom %.2f and sumlikeli[%d] %.2f",r_random,i,sum_likelihood[i]);
//            r_random =generate_rand_float();
//            if ((r_random> sum_likelihood[i]) && (likelihood[i]<likelihood[i+1]));
//            temporary[i]=next_population[i];
//        }
//    for(i=1; i<pop_size+1; i++) //print out new chromosome
//    {
//        next_population[i] = temporary[i];
//        //printf("\n\tchromosome[%d] = ",i);
//        for(j=0; j<num_nodes; j++)
//        {
//            //printf("%d",next_population[i].gene[j]);
//        }
//        next_population[i].fitness_score = Objective_function(next_population[i],num_nodes,edge_energy); //fitness score of chromosome
//        //printf(" fitness=%f",next_population[i].fitness_score); // print the fitness and value of chromosome for each respective chromosome
//    }
//    fflush(NULL);
//    return(0);
//}
//


//***********************************************************************************************************************
//***********************************************************************************************************************
//***********************************************************************************************************************
//***********************************************************************************************************************
//***********************************************************************************************************************
void print_out_chroms(int num_nodes,chrom* next_population, int j, int best, int current_generation)
{
    int x,y;
    if (best == TRUE)
    {
        printf("\n\n\t\tBest chromosome of Gen %d: ", current_generation);
        for(x=1; x<=num_nodes; x++)
        {
            printf("\n\t Node %d:",x );
            fprintf(fp,".");
            for(y=1; y<=num_nodes; y++)
            {
                fprintf(fp,"%d",next_population[1].gene[x][y].label);
                printf(" %d",next_population[1].gene[x][y].label);
            }
        }
    }
    else
    {
        printf("\n Chromosome[%d] = ",j);
        for(x=1; x<=num_nodes; x++)
        {
            printf("\n Node %d:",x );
            for(y=1; y<=num_nodes; y++)
                printf(" %d",next_population[j].gene[x][y].label);
        }
    }
}

void gen_init_pop(int num_nodes, int pop_size, int visited[], chrom *temp, chrom *current_population)
{
    int num_edges=1;
    int rand;
    int i,j, x,y,n;
    printf("\n\n\t Initial population");
    //make random solutions for initial populations
    for(i=1; i<=pop_size; i++) //for each chromosome
    {
        for(j=1; j<=num_nodes; j++) //for each solution clear the visited list
            visited[j]=0;

        num_edges =1;
        printf("\n\nPopulation: %d ",i);
        visited[1]=1;//set node one as the source node

        while(num_edges < num_nodes)//have required #edges = #node-1
        {
            for(x=1; x<=num_nodes; x++)
                for(y=1; y<=num_nodes; y++)//for all edges
                    if(visited[x]!=0)//if node is visited
                        if(current_population[i].gene[x][y].weight!=MAX_ENERGY) //if edge is possible
                            if(visited[y]==0)//if node is not yet visited
                            {
                                rand = rand_binary();
                                current_population[i].gene[x][y].label=rand;//randomly add an edge
                                if (rand == 1)
                                {
                                    visited [y] = 1;
                                    printf("\n Edge1 %d:(%d %d) energy:%.1f, label:%d",num_edges++,x,y,current_population[i].gene[x][y].weight,current_population[i].gene[x][y].label);
                                    for(n=1; n<=num_nodes; n++)
                                        if(n!=y)//find different edge connected to node x
                                            if (current_population[i].gene[x][n].weight != MAX_ENERGY)//if edge is possible
                                                if(current_population[i].gene[x][n].weight<= current_population[i].gene[x][y].weight)// node can reach all other nodes with equal or lower tx power
                                                    if(visited[n]==0)//if node is not yet visited
                                                    {
                                                        visited[n]=1;
                                                        current_population[i].gene[x][n].label = 1;
                                                        printf("\n Edge2 %d:(%d %d) energy:%.1f, label:%d",num_edges++,x,n,current_population[i].gene[x][n].weight,current_population[i].gene[x][n].label);
                                                        current_population[i].gene[x][n].weight=current_population[i].gene[n][x].weight=MAX_ENERGY;//make sure same edge is not chosen twice
                                                    }
                                    current_population[i].gene[x][y].weight=current_population[i].gene[y][x].weight=MAX_ENERGY;//make sure same edge is not chosen twice
                                }
                            }
        }

    }
    //transfer original weight back
    for(i=1; i<=pop_size; i++)
        for(x=1; x<=num_nodes; x++)
            for(y=1; y<=num_nodes; y++)
                current_population[i].gene[x][y].weight = temp[i].gene[x][y].weight;

}

void get_network_topology(int num_nodes, int pop_size, int visited[], chrom *temp, chrom *current_population)
{
    int i,x,y;
    float distance;

    //ask for the energy needed of each edge the node takes and store them
    printf("\nEnter the network topology matrix:\n");
    for(x=1; x<=num_nodes; x++)
        for(y=1; y<=num_nodes; y++)
        {
            scanf("%f", &distance);
            for(i=1; i<=pop_size; i++)
                current_population[i].gene[x][y].weight = distance;
        }
    for(i=1; i<=pop_size; i++)
        for(x=1; x<=num_nodes; x++)
            for(y=1; y<=num_nodes; y++)
            {
                temp[i].gene[x][y].weight = current_population[i].gene[x][y].weight;//store data of weights as initial_SA.weight will be modified temporarily for calculations
                current_population[i].gene[x][y].label =0;//initially start with no tree
                visited[x]=0;//no nodes visited at the start
            }

}

float Objective_function(int num_nodes,int i,chrom *next_population)
{

    float new_cost=0.0;
   // float function_value;

    new_cost = cost(num_nodes,i,next_population);
 //   if ()//it does not include all nodes set to 0

 //minimise the function

    return(new_cost);
}

float cost(int num_nodes,int i,chrom *next_population)
{
    float new_cost = 0.0;
    int x,y;
    float weight;

    for(x=1; x<=num_nodes; x++)//for all edges
    {
        weight =0.0;//find the largest tx on each node
        for(y=1; y<=num_nodes; y++)
            if(next_population[i].gene[x][y].label == 1)
                    if(weight<next_population[i].gene[x][y].weight)//find highest energy used per node
                        weight = next_population[i].gene[x][y].weight;

        new_cost += weight;//find total weight
    }
    printf("\n Total cost is %.1f\n\n", new_cost);

    return new_cost;
}

void *do_mutation_operator(int mutation,chrom ***next_population,int num_nodes, int pop_size, float mutation_rate)
{
    switch (mutation)
    {
    case 1 :
        //mutation_addRemove()
        break;
    case 2 :
        //mutation_loopRemove()
        break;
    default :
        printf("invalid input\n" );
        break;
    }
    return 0;
}

void *do_crossover_operator(int crossover,chrom ***next_population,int num_nodes, int pop_size)
{
    switch (crossover)
    {
    case 1 :
        //crossover_sameBranches
        break;
    case 2 :
        //crossover_swapBranches
        break;
    default :
        printf("invalid input\n" );
        break;
    }
    return 0;
}

void *do_selection_operator(int selection,chrom ***next_population,int num_nodes, int pop_size)
{
    int show=1;
    switch (selection)
    {
    case 1 :
        //selection_elitism_sort( pop_size,next_population,num_nodes,show,edge_energy);
        break;
    case 2 :
        //selection_tournament(pop_size,next_population,num_nodes,edge_energy);
        break;
    case 3 :
        //selection_rank(pop_size,next_population,num_nodes,edge_energy);
        break;
    case 4 :
        //selection_roulettewheel(pop_size,next_population, num_nodes,edge_energy);
        break;
    default :
        printf("invalid input\n" );
        break;
    }
    return 0;
}

int generate_rand(int Min, int Max)
{
    // Generates random number between min and max, inclusive.
    //From: http://cboard.cprogramming.com/c-programming/145187-how-pick-random-number-between-x-y.html

    int range, result, cutoff;

    if (Min >= Max)
        return Min; // only one outcome possible, or invalid parameters
    range = Max-Min+1;
    cutoff = (RAND_MAX / range) * range;

    // Rejection method, to be statistically unbiased.
    do
    {
        result = rand();
    }
    while (result >= cutoff);

    return result % range + Min;
}

int rand_binary(void)
{
    int random;

    random = rand()%2;
    return random;
}

float generate_rand_float(void)
{
    float random_value; // random value betw

    random_value = ((float)rand()/(float)(RAND_MAX+1));//version 1
    //Alternatively:
    //random_value = ((rand()%10000000)/10000000);

    return random_value;
}

int get_restart(void)
{
    int restart; //number of chromosomes entered

    printf("\n\n\n\n\tWould you like to restart? (1 = yes)\t");// ask if they want to restart
    scanf("%d",&restart);

    return restart;
}

float get_mutation_rate(void)
{
    float mutation_rate; //number of chromosomes entered

    enter:
    printf("Please enter (float) mutation rate (Minimum %d to Maximum %d):\t",MIN_MUTATION_RATE,MAX_MUTATION_RATE);// Ask for number of chromosomes
    scanf("%f",&mutation_rate); //get the number of chromosomes

    if(mutation_rate <MIN_MUTATION_RATE || mutation_rate>MAX_MUTATION_RATE)
        goto enter;

    return mutation_rate;
}

int get_chromosome_size(void)
{
    int num_nodes; //problem size

enter:
    printf("Please enter no. of Nodes considered (Min %d to Max %d):\t",MIN_CHROMO_SIZE,MAX_CHROMO_SIZE);// Ask for number of chromosomes
    scanf("%d",&num_nodes); //get the number of chromosomes


    if(num_nodes <MIN_CHROMO_SIZE || num_nodes>MAX_CHROMO_SIZE)
        goto enter;
    return (num_nodes);
}

int get_population_size(void)
{
    int pop_size; //number of population entered
//
//enter:
//    printf("Please enter an even population size (Minimum %d to Maximum of %d):\t",MIN_POP_SIZE,MAX_POP_SIZE);// Ask for number of population
//    scanf("%d",&pop_size); //get the number of population
//
//    if(pop_size <MIN_POP_SIZE || pop_size>MAX_POP_SIZE)
//        goto enter;
//    else if(pop_size%2 !=0)
//        goto enter;

    return pop_size=2;
}

int get_mutation_strategy(void)
{
    int mutation; //number of population entered

enter:
    printf("\n\tChoose a mutation strategy: \
                 \n\t\tAdd/Remove        \t 1       \
                 \n\t\tLoop/Remove       \t 2\
                 \n\t\tYou picked:");// Ask for mutation strategy

    scanf("%d",&mutation); //get the number of population

    if(mutation <1 || mutation>2)
        goto enter;
    return mutation;
}

int get_crossover_strategy(void)
{
    int crossover; //number of population entered

enter:
    printf("\n\tChoose a crossover strategy: \
                 \n\t\tSame Branches    \t 1       \
                 \n\t\tSwap Branches    \t 2       \
                 \n\t\tYou picked:");// Ask for crossover strategy

    scanf("%d",&crossover); //get the number of population

    if(crossover <1 || crossover>2)
        goto enter;
    return crossover;
}

int get_selection_strategy(void)
{
    int selection; //number of population entered

enter:
    printf("\n\tChoose a selection strategy: \
                 \n\t\tElitism         \t 1       \
                 \n\t\tTournament      \t 2       \
                 \n\t\tRank            \t 3       \
                 \n\t\tRoulette Wheel  \t 4       \
                 \n\t\tYou picked:");// Ask for selection strategy

    scanf("%d",&selection); //get the number of population

    if(selection <1 || selection>4)
        goto enter;
    return selection;
}

int get_num_generation(void)
{
    int num; //number of generations entered

enter:
    printf("Please enter the number of generations (Minimum 1 to Maximum of %d):\t",MAX_GENERATIONS);// Ask for number of generation for stopping criterion
    scanf("%d",&num); //get the number of generations

    if(num < 1 || num > MAX_GENERATIONS)
        goto enter;
    return num;
}

void introduction (void)
{
    printf("\n\n\n\n\n\nWelcome to the Genetic Algorithm coded by Daniella Bacud\n"); // Print introduction
}
